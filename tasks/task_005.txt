# Task ID: 5
# Title: Implement WordTransform component
# Status: in-progress
# Dependencies: 2, 4
# Priority: high
# Description: Create the WordTransform component that orchestrates the full animation sequence using the Letter components.
# Details:
Develop the WordTransform component that takes misspelled and correct words as inputs and orchestrates the full animation sequence. Use the algorithm utilities from Task 2 to compute the edit plan. Render a sequence of Letter components and control their animations using Framer Motion's AnimatePresence and sequence capabilities. Implement the three-phase animation: 1) deletions, 2) movements, 3) insertions. Support variable animation speed through a speed multiplier prop. Ensure smooth transitions between animation phases.

# Test Strategy:
Test the WordTransform component with various word pairs, including edge cases. Verify the animation sequence is correct and responsive. Use React Testing Library to check component rendering and state management.

# Subtasks:
## 1. Set up WordTransform component with TypeScript interfaces [done]
### Dependencies: None
### Description: Create the basic structure of the WordTransform component with proper TypeScript interfaces, props definition, and state management for the animation sequence.
### Details:
Create a new file for the WordTransform component. Define TypeScript interfaces for props (misspelledWord, correctWord, speedMultiplier, etc.). Set up the component's initial state including animation phase tracking (idle, deleting, moving, inserting). Create a skeleton for the component that accepts props and renders a container for the letters. Add CSS variables for animation timing that will be influenced by the speedMultiplier prop.
<info added on 2025-05-05T01:10:20.674Z>
Create a new file for the WordTransform component. Define TypeScript interfaces for props (misspelledWord, correctWord, speedMultiplier, etc.). Set up the component's initial state including animation phase tracking (idle, deleting, moving, inserting). Create a skeleton for the component that accepts props and renders a container for the letters. Add CSS variables for animation timing that will be influenced by the speedMultiplier prop.

Implementation details:
- Created WordTransform.tsx with TypeScript interfaces for all required props (misspelledWord, correctWord) and optional props (speedMultiplier with default 1, className, animation event callbacks, cancelOnPropsChange flag)
- Implemented state management using useReducer with an AnimationPhase enum to track animation progress
- Created a comprehensive animation reducer with appropriate action types for phase transitions
- Developed WordTransform.module.css with CSS variables for animation durations (--remove-duration, --add-duration, --reorder-duration)
- Added support for dynamic visual feedback using data-phase attributes
- Implemented accessibility features including reduced motion preference detection
- Set up logic to dynamically modify animation durations based on the speedMultiplier prop
- Added data-phase attributes for E2E testing and debugging purposes

The component structure is now complete with all TypeScript interfaces defined. The next step is to integrate the word transformation algorithm from the next subtask and implement the actual animation logic.
</info added on 2025-05-05T01:10:20.674Z>
<info added on 2025-05-07T01:14:37.820Z>
The WordTransform component has been enhanced with several improvements based on code review feedback:

1. Renamed the `speed` prop to `speedMultiplier` for better consistency with the specification. This change has been propagated throughout the component, including all CSS variable calculations and test files.

2. Fixed an effect dependencies issue by removing `state.isAnimating` from the dependencies array of the initialization effect, preventing unwanted animation resets during the animation process.

3. Implemented memoization for the computeEditPlan function using React's useMemo hook. This optimization prevents unnecessary recalculations when the component re-renders for reasons unrelated to word changes.

4. Added proper visual differentiation for "true movers" (letters that move to new positions rather than being deleted/added):
   - Created a new `ExtendedLetterAnimationState` type that includes a 'true-movement' state
   - Enhanced the `getLetterAnimationState` function to specifically identify true movers
   - Added a mapping function to convert extended states to standard Letter component states
   - Implemented a special CSS class `.trueMover` with enhanced styling (bold, increased brightness and saturation)
   - Applied the trueMover class conditionally to Letter components

5. Added data attributes throughout the component for improved testing and debugging capabilities

All tests are now passing with these improvements, and the component is ready for integration with the word transformation algorithm.
</info added on 2025-05-07T01:14:37.820Z>

## 2. Integrate word transformation algorithm [done]
### Dependencies: None
### Description: Connect the WordTransform component with the algorithm utilities to compute the edit plan for transforming the misspelled word into the correct word.
### Details:
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.
<info added on 2025-05-07T00:09:28.358Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

The integration of the word transformation algorithm has been implemented with the following components:

1. Enhanced the initialization useEffect to include state.isAnimating in the dependencies array to properly track animation state changes.

2. Created a memoized handlePhaseChange function that calls the onPhaseChange callback when animation phases transition.

3. Implemented a dedicated useEffect to manage phase transitions based on the computed edit plan:
   - Calculates the total number of animations required for each phase
   - Intelligently skips phases that don't require animations (e.g., when no deletions are needed)
   - Dispatches appropriate actions to initiate each animation phase
   - Triggers the completion callback when the entire animation sequence finishes

4. Added an effect to monitor when all animations in the current phase are complete to trigger the next phase.

5. Developed helper functions to manage the animation flow:
   - startAnimation function to begin the animation sequence
   - handleLetterAnimationComplete function to track completion of individual letter animations

6. Enhanced the UI with debugging and testing features:
   - Added a manual animation start button for testing purposes
   - Included debug information displaying the edit plan details (showing deletions, moves, and insertions)

The implementation successfully handles edge cases including empty strings and identical words by computing appropriate edit plans and automatically transitioning through unnecessary phases. This completes the core algorithm integration, setting the foundation for the next subtask of implementing the animation state machine.
</info added on 2025-05-07T00:09:28.358Z>
<info added on 2025-05-07T01:23:53.329Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

<info added on 2025-05-07T00:09:28.358Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

The integration of the word transformation algorithm has been implemented with the following components:

1. Enhanced the initialization useEffect to include state.isAnimating in the dependencies array to properly track animation state changes.

2. Created a memoized handlePhaseChange function that calls the onPhaseChange callback when animation phases transition.

3. Implemented a dedicated useEffect to manage phase transitions based on the computed edit plan:
   - Calculates the total number of animations required for each phase
   - Intelligently skips phases that don't require animations (e.g., when no deletions are needed)
   - Dispatches appropriate actions to initiate each animation phase
   - Triggers the completion callback when the entire animation sequence finishes

4. Added an effect to monitor when all animations in the current phase are complete to trigger the next phase.

5. Developed helper functions to manage the animation flow:
   - startAnimation function to begin the animation sequence
   - handleLetterAnimationComplete function to track completion of individual letter animations

6. Enhanced the UI with debugging and testing features:
   - Added a manual animation start button for testing purposes
   - Included debug information displaying the edit plan details (showing deletions, moves, and insertions)

The implementation successfully handles edge cases including empty strings and identical words by computing appropriate edit plans and automatically transitioning through unnecessary phases. This completes the core algorithm integration, setting the foundation for the next subtask of implementing the animation state machine.
</info added on 2025-05-07T00:09:28.358Z>

Following the implementation of the core algorithm integration, several significant improvements have been made to the WordTransform component based on developer feedback:

1. Renamed the 'speed' prop to 'speedMultiplier' for better alignment with the specification:
   - Updated all references to this prop throughout the component
   - Adjusted CSS variable calculations that depend on this value
   - Updated test files to reflect the new prop name

2. Fixed a critical effect dependencies issue:
   - Removed state.isAnimating from the dependencies array in the initialization effect
   - This prevents unwanted resets when animation begins, improving stability

3. Optimized performance with memoization for the computeEditPlan function:
   - Implemented useMemo for the edit plan calculation
   - The calculation now only runs when misspelling or correct props change
   - Added TypeScript null safety checks to prevent runtime errors

4. Enhanced visual differentiation for "true movers":
   - Created an ExtendedLetterAnimationState type that includes a 'true-movement' state
   - Improved the getLetterAnimationState function to specifically identify true movers
   - Added a helper function to map extended states to standard Letter states
   - Implemented a special .trueMover CSS class with enhanced styling for better user experience

5. Improved state machine clarity and maintainability:
   - Added a visual phase transition diagram in the component comments
   - Created a PHASE_TRANSITIONS map for declarative next-state determination
   - Refactored phase transition logic to be more declarative using a configuration object
   - Added proper TypeScript interfaces for the phase configuration

6. Implemented comprehensive testing for the animation state machine:
   - Added tests for animation phase transitions
   - Verified callback behavior (onAnimationStart, onPhaseChange, onAnimationComplete)
   - Created tests for prop changes during animation

These improvements have significantly enhanced the component's maintainability, performance, and visual appeal while addressing all key points from the code review. The WordTransform component now provides a more robust and efficient implementation of the word transformation algorithm with improved animation control.
</info added on 2025-05-07T01:23:53.329Z>

## 3. Implement animation state machine [done]
### Dependencies: None
### Description: Create a state machine to manage the three phases of animation (deletions, movements, insertions) and handle transitions between them.
### Details:
Implement a state machine using useReducer for more predictable state transitions and easier testing. Define reducer actions for each animation phase (deleting, moving, inserting, complete). Create transition functions to move from one phase to the next when the current phase completes. Use Framer Motion's AnimatePresence for managing components entering/exiting the DOM. Implement timing calculations based on the speedMultiplier prop. Add event handlers to detect when animations complete to trigger the next phase.
<info added on 2025-05-07T00:46:36.630Z>
Implement a state machine using useReducer for more predictable state transitions and easier testing. Define reducer actions for each animation phase (deleting, moving, inserting, complete). Create transition functions to move from one phase to the next when the current phase completes. Use Framer Motion's AnimatePresence for managing components entering/exiting the DOM. Implement timing calculations based on the speedMultiplier prop. Add event handlers to detect when animations complete to trigger the next phase.

The implementation includes a getLetterAnimationState function that determines the appropriate animation state for each letter based on the current animation phase (DELETING, MOVING, INSERTING), the letter's position in the word, and the edit plan (deletions, moves, insertions). A renderLetters function handles null safety for the edit plan and uses a switch statement to handle different animation phases. It renders source letters (misspelled word) during IDLE, DELETING, and MOVING phases, and target letters (correct word) during INSERTING and COMPLETE phases. The function applies appropriate animation states to each letter and sets onAnimationComplete callbacks only on letters that should trigger phase transitions.

The component's main render method uses the renderLetters function, displays a Start Animation button only in the IDLE phase, shows debugging information about the current animation state, and applies proper CSS classes for styling. CSS styles maintain visual consistency and support animations through lettersContainer styles for the letter display area, animation control button styles, debug info display styling, and layout adjustments to properly show all elements. Tests have been updated to adapt to the new component structure that renders individual letters instead of text strings.
</info added on 2025-05-07T00:46:36.630Z>

## 4. Render and animate Letter components [pending]
### Dependencies: None
### Description: Implement the rendering logic for Letter components with proper animation attributes based on the current animation phase.
### Details:
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.
<info added on 2025-05-05T01:22:16.869Z>
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.

After implementing the Letter component rendering:
1. Create a WordTransform.stories.tsx file with stories for different animation states (idle, deleting, inserting, and transitioning)
2. Include stories for both regular and reduced motion modes to ensure accessibility compliance
3. Run Storybook to visually verify the component works correctly across all animation phases
4. Set up initial snapshot tests with Storybook test runner to catch unintended visual regressions
</info added on 2025-05-05T01:22:16.869Z>
<info added on 2025-05-05T01:22:37.630Z>
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.

In addition to unit tests, implement comprehensive Storybook visual testing for the Letter components. Create stories that showcase each animation phase (idle, deleting, inserting, transitioning) and verify the visual appearance and behavior matches the expected design. Use Storybook's interaction testing capabilities to simulate user interactions and animation triggers. Implement visual regression tests using Chromatic or a similar tool to catch unintended visual changes. This dual testing approach (unit tests + visual testing) will ensure both the functional logic and visual appearance are correctly maintained.
</info added on 2025-05-05T01:22:37.630Z>
<info added on 2025-05-05T01:22:56.734Z>
The test strategy for this subtask should be expanded to include Storybook testing. In addition to unit tests that verify the correct number of Letter components are rendered with appropriate props for each animation phase, we should implement Storybook stories to visually test the component behavior.

Specifically, we should:
1. Create Storybook stories for each animation phase (idle, deleting, inserting, transitioning)
2. Include stories that demonstrate both regular and reduced motion modes for accessibility
3. Add interaction tests in Storybook to verify animation triggers work correctly
4. Implement visual regression testing using Chromatic or similar tools
5. Document the testing approach in the component's README

This comprehensive testing approach will ensure both functional correctness and visual consistency of the Letter components throughout the animation lifecycle.
</info added on 2025-05-05T01:22:56.734Z>

## 5. Handle prop changes and optimize performance [pending]
### Dependencies: None
### Description: Implement proper handling of prop changes during animation and optimize the component for performance.
### Details:
Decide and implement behavior for when props change mid-animation (restart, complete current animation first, etc.). Add a reset function to cleanly restart animations when words change. Implement memoization using useMemo and useCallback to prevent unnecessary re-renders. Add optional callback props for animation events (onAnimationStart, onPhaseChange, onAnimationComplete). Ensure smooth transitions between all animation phases with no visual glitches. Add final polish including accessibility attributes and responsive behavior.

## 6. Integrate CSS variables for animation timing [pending]
### Dependencies: None
### Description: Set up and integrate CSS variables for animation timing from the stylesheet to ensure consistent animation speeds across the component.
### Details:
Create a set of CSS variables in the component's stylesheet for different animation durations and delays (e.g., --deletion-duration, --movement-duration, --insertion-duration). Implement a mechanism to modify these CSS variables based on the speedMultiplier prop. Use React's useRef to access the component's DOM element and update CSS variables programmatically. Ensure all animations reference these variables instead of hardcoded timing values. Add a helper function to calculate and update all timing variables when the speed multiplier changes.

## 7. Add data-phase attributes and testing hooks [pending]
### Dependencies: None
### Description: Implement data-phase attributes and testing hooks to facilitate E2E testing and debugging of the animation sequence.
### Details:
Add data-phase attributes to the component's container element that reflect the current animation phase (e.g., data-phase="deleting", data-phase="moving"). Add data-testid attributes to key elements for easier selection in tests. Create a debug mode prop that, when enabled, adds additional data attributes showing the internal state of each letter (e.g., data-letter-state="deleted", data-letter-state="moving"). Implement a testing API through ref forwarding that exposes internal state and methods for testing purposes. Document all testing hooks and attributes for the QA team.

## 8. Define and unit-test WordTransform finite state machine [pending]
### Dependencies: None
### Description: Create a finite state machine for the WordTransform component that manages the animation sequence states and transitions.
### Details:
Create src/components/wordTransform.machine.ts with XState defining five states: idle, deleting, moving, inserting, and complete. Include context to track deletion/move/insertion counts. Define events (START, DONE_PHASE, RESET) that trigger transitions between states. Implement logic to skip phases with zero-length operations. Ensure the machine handles the complete animation lifecycle and can be reset.

## 9. Implement WordTransform component with FSM integration [pending]
### Dependencies: 5.8
### Description: Develop the WordTransform component that uses the state machine to orchestrate the animation sequence of Letter components.
### Details:
Create the WordTransform component that takes misspelled and correct words as props. Replace any existing useReducer/useEffect logic with useMachine(wordTransformMachine). Use the algorithm utilities from Task 2 to compute the edit plan. Render Letter components based on the current animation phase. Implement event handlers to send('START') on animation start, send('DONE_PHASE') when Letter animations complete, and send('RESET') to restart. Map the machine's current state to visual feedback and control props. Support a speed multiplier prop that affects animation duration.

## 10. Update tests and add Storybook examples [pending]
### Dependencies: 5.9
### Description: Refactor existing tests to work with the state machine implementation and create Storybook examples showcasing the component.
### Details:
Update existing Jest/React Testing Library tests to interact with the component via state machine events. Add data-phase and data-testid attributes to key elements for test selection. Create E2E tests that verify the full animation sequence works correctly. Develop Storybook examples that demonstrate different animation scenarios: words with deletions only, insertions only, movements only, and combinations. Include examples with different speed multiplier values.

## 11. Wire true-mover animation state through to Letter component and Framer Motion [pending]
### Dependencies: 5.4, 5.5
### Description: Ensure the 'true-mover' animation state is passed through to the Letter component and Framer Motion. Do not collapse it to 'movement'. Add a Framer Motion variant and/or prop for true-mover in Letter. Update CSS/animation for true-mover to provide distinct visual and motion feedback.
### Details:
- Update mapToLetterAnimationState and/or Letter props to allow 'true-mover' to be passed through.
- Add a Framer Motion variant and/or prop for 'true-mover' in Letter.
- Update Letter.module.css and animation logic to provide distinct styling and motion for true-movers.
- Ensure the WordTransform component applies the correct class/data-attribute for true-movers.
- Test visually in Storybook and with unit tests.

## 12. Expand Jest/RTL test suite for WordTransform: phase transitions, CSS vars, and true-mover rendering [pending]
### Dependencies: 5.11
### Description: Add integration/unit tests for WordTransform using fake timers and deterministic edit plans. Assert phase transitions (IDLE→DELETING→MOVING→INSERTING→COMPLETE), CSS variable changes for speedMultiplier, and true-mover rendering (class, data-attribute, or animation variant).
### Details:
- Use jest.useFakeTimers() and jest.runAllTimers() to control animation timing in tests.
- Mock computeEditPlan to return a known plan (e.g., for 'ab'→'ba', highlight index 0 or 1).
- Assert:
  - CSS variable changes for speedMultiplier
  - Phase transitions (IDLE → DELETING → MOVING → INSERTING → COMPLETE)
  - That a true-mover letter gets the correct class/data-attribute and/or animation variant
- Add tests to src/components/__tests__/WordTransform.test.tsx.

