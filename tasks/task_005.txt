# Task ID: 5
# Title: Implement WordTransform component
# Status: in-progress
# Dependencies: 2, 4
# Priority: high
# Description: Create the WordTransform component that orchestrates the full animation sequence using the Letter components.
# Details:
Develop the WordTransform component that takes misspelled and correct words as inputs and orchestrates the full animation sequence. Use the algorithm utilities from Task 2 to compute the edit plan. Render a sequence of Letter components and control their animations using Framer Motion's AnimatePresence and sequence capabilities. Implement the three-phase animation: 1) deletions, 2) movements, 3) insertions. Support variable animation speed through a speed multiplier prop. Ensure smooth transitions between animation phases.

# Test Strategy:
Test the WordTransform component with various word pairs, including edge cases. Verify the animation sequence is correct and responsive. Use React Testing Library to check component rendering and state management.

# Subtasks:
## 1. Set up WordTransform component with TypeScript interfaces [done]
### Dependencies: None
### Description: Create the basic structure of the WordTransform component with proper TypeScript interfaces, props definition, and state management for the animation sequence.
### Details:
Create a new file for the WordTransform component. Define TypeScript interfaces for props (misspelledWord, correctWord, speedMultiplier, etc.). Set up the component's initial state including animation phase tracking (idle, deleting, moving, inserting). Create a skeleton for the component that accepts props and renders a container for the letters. Add CSS variables for animation timing that will be influenced by the speedMultiplier prop.
<info added on 2025-05-05T01:10:20.674Z>
Create a new file for the WordTransform component. Define TypeScript interfaces for props (misspelledWord, correctWord, speedMultiplier, etc.). Set up the component's initial state including animation phase tracking (idle, deleting, moving, inserting). Create a skeleton for the component that accepts props and renders a container for the letters. Add CSS variables for animation timing that will be influenced by the speedMultiplier prop.

Implementation details:
- Created WordTransform.tsx with TypeScript interfaces for all required props (misspelledWord, correctWord) and optional props (speedMultiplier with default 1, className, animation event callbacks, cancelOnPropsChange flag)
- Implemented state management using useReducer with an AnimationPhase enum to track animation progress
- Created a comprehensive animation reducer with appropriate action types for phase transitions
- Developed WordTransform.module.css with CSS variables for animation durations (--remove-duration, --add-duration, --reorder-duration)
- Added support for dynamic visual feedback using data-phase attributes
- Implemented accessibility features including reduced motion preference detection
- Set up logic to dynamically modify animation durations based on the speedMultiplier prop
- Added data-phase attributes for E2E testing and debugging purposes

The component structure is now complete with all TypeScript interfaces defined. The next step is to integrate the word transformation algorithm from the next subtask and implement the actual animation logic.
</info added on 2025-05-05T01:10:20.674Z>
<info added on 2025-05-07T01:14:37.820Z>
The WordTransform component has been enhanced with several improvements based on code review feedback:

1. Renamed the `speed` prop to `speedMultiplier` for better consistency with the specification. This change has been propagated throughout the component, including all CSS variable calculations and test files.

2. Fixed an effect dependencies issue by removing `state.isAnimating` from the dependencies array of the initialization effect, preventing unwanted animation resets during the animation process.

3. Implemented memoization for the computeEditPlan function using React's useMemo hook. This optimization prevents unnecessary recalculations when the component re-renders for reasons unrelated to word changes.

4. Added proper visual differentiation for "true movers" (letters that move to new positions rather than being deleted/added):
   - Created a new `ExtendedLetterAnimationState` type that includes a 'true-movement' state
   - Enhanced the `getLetterAnimationState` function to specifically identify true movers
   - Added a mapping function to convert extended states to standard Letter component states
   - Implemented a special CSS class `.trueMover` with enhanced styling (bold, increased brightness and saturation)
   - Applied the trueMover class conditionally to Letter components

5. Added data attributes throughout the component for improved testing and debugging capabilities

All tests are now passing with these improvements, and the component is ready for integration with the word transformation algorithm.
</info added on 2025-05-07T01:14:37.820Z>

## 2. Integrate word transformation algorithm [done]
### Dependencies: None
### Description: Connect the WordTransform component with the algorithm utilities to compute the edit plan for transforming the misspelled word into the correct word.
### Details:
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.
<info added on 2025-05-07T00:09:28.358Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

The integration of the word transformation algorithm has been implemented with the following components:

1. Enhanced the initialization useEffect to include state.isAnimating in the dependencies array to properly track animation state changes.

2. Created a memoized handlePhaseChange function that calls the onPhaseChange callback when animation phases transition.

3. Implemented a dedicated useEffect to manage phase transitions based on the computed edit plan:
   - Calculates the total number of animations required for each phase
   - Intelligently skips phases that don't require animations (e.g., when no deletions are needed)
   - Dispatches appropriate actions to initiate each animation phase
   - Triggers the completion callback when the entire animation sequence finishes

4. Added an effect to monitor when all animations in the current phase are complete to trigger the next phase.

5. Developed helper functions to manage the animation flow:
   - startAnimation function to begin the animation sequence
   - handleLetterAnimationComplete function to track completion of individual letter animations

6. Enhanced the UI with debugging and testing features:
   - Added a manual animation start button for testing purposes
   - Included debug information displaying the edit plan details (showing deletions, moves, and insertions)

The implementation successfully handles edge cases including empty strings and identical words by computing appropriate edit plans and automatically transitioning through unnecessary phases. This completes the core algorithm integration, setting the foundation for the next subtask of implementing the animation state machine.
</info added on 2025-05-07T00:09:28.358Z>
<info added on 2025-05-07T01:23:53.329Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

<info added on 2025-05-07T00:09:28.358Z>
Import the algorithm utilities from Task 2. Implement a useEffect hook that computes the transformation plan when either word changes. The plan should identify which letters need to be deleted, which ones need to be moved, and which ones need to be inserted. Store this plan in component state. Handle edge cases such as empty strings, identical words, or completely different words. Ensure the algorithm results are properly typed and structured for the animation phases.

The integration of the word transformation algorithm has been implemented with the following components:

1. Enhanced the initialization useEffect to include state.isAnimating in the dependencies array to properly track animation state changes.

2. Created a memoized handlePhaseChange function that calls the onPhaseChange callback when animation phases transition.

3. Implemented a dedicated useEffect to manage phase transitions based on the computed edit plan:
   - Calculates the total number of animations required for each phase
   - Intelligently skips phases that don't require animations (e.g., when no deletions are needed)
   - Dispatches appropriate actions to initiate each animation phase
   - Triggers the completion callback when the entire animation sequence finishes

4. Added an effect to monitor when all animations in the current phase are complete to trigger the next phase.

5. Developed helper functions to manage the animation flow:
   - startAnimation function to begin the animation sequence
   - handleLetterAnimationComplete function to track completion of individual letter animations

6. Enhanced the UI with debugging and testing features:
   - Added a manual animation start button for testing purposes
   - Included debug information displaying the edit plan details (showing deletions, moves, and insertions)

The implementation successfully handles edge cases including empty strings and identical words by computing appropriate edit plans and automatically transitioning through unnecessary phases. This completes the core algorithm integration, setting the foundation for the next subtask of implementing the animation state machine.
</info added on 2025-05-07T00:09:28.358Z>

Following the implementation of the core algorithm integration, several significant improvements have been made to the WordTransform component based on developer feedback:

1. Renamed the 'speed' prop to 'speedMultiplier' for better alignment with the specification:
   - Updated all references to this prop throughout the component
   - Adjusted CSS variable calculations that depend on this value
   - Updated test files to reflect the new prop name

2. Fixed a critical effect dependencies issue:
   - Removed state.isAnimating from the dependencies array in the initialization effect
   - This prevents unwanted resets when animation begins, improving stability

3. Optimized performance with memoization for the computeEditPlan function:
   - Implemented useMemo for the edit plan calculation
   - The calculation now only runs when misspelling or correct props change
   - Added TypeScript null safety checks to prevent runtime errors

4. Enhanced visual differentiation for "true movers":
   - Created an ExtendedLetterAnimationState type that includes a 'true-movement' state
   - Improved the getLetterAnimationState function to specifically identify true movers
   - Added a helper function to map extended states to standard Letter states
   - Implemented a special .trueMover CSS class with enhanced styling for better user experience

5. Improved state machine clarity and maintainability:
   - Added a visual phase transition diagram in the component comments
   - Created a PHASE_TRANSITIONS map for declarative next-state determination
   - Refactored phase transition logic to be more declarative using a configuration object
   - Added proper TypeScript interfaces for the phase configuration

6. Implemented comprehensive testing for the animation state machine:
   - Added tests for animation phase transitions
   - Verified callback behavior (onAnimationStart, onPhaseChange, onAnimationComplete)
   - Created tests for prop changes during animation

These improvements have significantly enhanced the component's maintainability, performance, and visual appeal while addressing all key points from the code review. The WordTransform component now provides a more robust and efficient implementation of the word transformation algorithm with improved animation control.
</info added on 2025-05-07T01:23:53.329Z>

## 3. Implement animation state machine [done]
### Dependencies: None
### Description: Create a state machine to manage the three phases of animation (deletions, movements, insertions) and handle transitions between them.
### Details:
Implement a state machine using useReducer for more predictable state transitions and easier testing. Define reducer actions for each animation phase (deleting, moving, inserting, complete). Create transition functions to move from one phase to the next when the current phase completes. Use Framer Motion's AnimatePresence for managing components entering/exiting the DOM. Implement timing calculations based on the speedMultiplier prop. Add event handlers to detect when animations complete to trigger the next phase.
<info added on 2025-05-07T00:46:36.630Z>
Implement a state machine using useReducer for more predictable state transitions and easier testing. Define reducer actions for each animation phase (deleting, moving, inserting, complete). Create transition functions to move from one phase to the next when the current phase completes. Use Framer Motion's AnimatePresence for managing components entering/exiting the DOM. Implement timing calculations based on the speedMultiplier prop. Add event handlers to detect when animations complete to trigger the next phase.

The implementation includes a getLetterAnimationState function that determines the appropriate animation state for each letter based on the current animation phase (DELETING, MOVING, INSERTING), the letter's position in the word, and the edit plan (deletions, moves, insertions). A renderLetters function handles null safety for the edit plan and uses a switch statement to handle different animation phases. It renders source letters (misspelled word) during IDLE, DELETING, and MOVING phases, and target letters (correct word) during INSERTING and COMPLETE phases. The function applies appropriate animation states to each letter and sets onAnimationComplete callbacks only on letters that should trigger phase transitions.

The component's main render method uses the renderLetters function, displays a Start Animation button only in the IDLE phase, shows debugging information about the current animation state, and applies proper CSS classes for styling. CSS styles maintain visual consistency and support animations through lettersContainer styles for the letter display area, animation control button styles, debug info display styling, and layout adjustments to properly show all elements. Tests have been updated to adapt to the new component structure that renders individual letters instead of text strings.
</info added on 2025-05-07T00:46:36.630Z>

## 4. Render and animate Letter components [done]
### Dependencies: None
### Description: Implement the rendering logic for Letter components with proper animation attributes based on the current animation phase.
### Details:
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.
<info added on 2025-05-05T01:22:16.869Z>
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.

After implementing the Letter component rendering:
1. Create a WordTransform.stories.tsx file with stories for different animation states (idle, deleting, inserting, and transitioning)
2. Include stories for both regular and reduced motion modes to ensure accessibility compliance
3. Run Storybook to visually verify the component works correctly across all animation phases
4. Set up initial snapshot tests with Storybook test runner to catch unintended visual regressions
</info added on 2025-05-05T01:22:16.869Z>
<info added on 2025-05-05T01:22:37.630Z>
Create a rendering system that maps the transformation plan to Letter components. Assign unique keys to each letter for stable identity during animations. Pass appropriate animation props to each Letter based on its role in the current phase (being deleted, moved, or inserted). Use Framer Motion's layout prop for automatic positioning. Implement staggered animations using custom delay calculations. Add data attributes to letters for testing and debugging purposes.

In addition to unit tests, implement comprehensive Storybook visual testing for the Letter components. Create stories that showcase each animation phase (idle, deleting, inserting, transitioning) and verify the visual appearance and behavior matches the expected design. Use Storybook's interaction testing capabilities to simulate user interactions and animation triggers. Implement visual regression tests using Chromatic or a similar tool to catch unintended visual changes. This dual testing approach (unit tests + visual testing) will ensure both the functional logic and visual appearance are correctly maintained.
</info added on 2025-05-05T01:22:37.630Z>
<info added on 2025-05-05T01:22:56.734Z>
The test strategy for this subtask should be expanded to include Storybook testing. In addition to unit tests that verify the correct number of Letter components are rendered with appropriate props for each animation phase, we should implement Storybook stories to visually test the component behavior.

Specifically, we should:
1. Create Storybook stories for each animation phase (idle, deleting, inserting, transitioning)
2. Include stories that demonstrate both regular and reduced motion modes for accessibility
3. Add interaction tests in Storybook to verify animation triggers work correctly
4. Implement visual regression testing using Chromatic or similar tools
5. Document the testing approach in the component's README

This comprehensive testing approach will ensure both functional correctness and visual consistency of the Letter components throughout the animation lifecycle.
</info added on 2025-05-05T01:22:56.734Z>
<info added on 2025-05-07T22:50:12.580Z>
Based on the exploration findings, I'll implement the rendering logic for Letter components with proper animation attributes. The implementation will focus on creating a function in WordTransform that maps the transformation plan to Letter components with appropriate animation props.

Key implementation steps:
1. Create a renderLetters() function in WordTransform that:
   - Takes the current transformation plan and animation phase as inputs
   - Maps over the appropriate letter array (source or target) based on the current phase
   - Assigns unique and stable keys to each letter (combining letter value and position)
   - Passes appropriate animation props based on the letter's role in the current phase
   - Calculates staggered delays for smooth sequential animations

2. Use Framer Motion features effectively:
   - Apply the `layout` prop to Letter components for automatic position transitions
   - Utilize AnimatePresence for enter/exit animations
   - Implement custom variants for each animation state (idle, deleting, moving, inserting)
   - Configure transition properties (duration, ease, delay) for optimal visual effect

3. Add data attributes to each Letter component:
   - data-phase: Current animation phase (deleting, moving, inserting, complete)
   - data-letter-state: Letter's specific state (being-deleted, being-moved, being-inserted, idle)
   - data-letter-index: Original position index for debugging and testing

4. Handle edge cases:
   - Multiple simultaneous letter operations
   - Empty strings or single-letter transformations
   - Proper synchronization with the animation state machine

5. After implementation:
   - Create comprehensive Storybook stories for each animation phase
   - Implement visual regression tests
   - Ensure accessibility compliance with reduced motion mode

I'll ensure the rendering logic correctly switches between source and target letters as appropriate for each phase, maintaining visual consistency throughout the animation sequence.
</info added on 2025-05-07T22:50:12.580Z>
<info added on 2025-05-07T22:59:43.789Z>
The implementation of the Letter component rendering and animation system has been completed with significant enhancements to ensure optimal performance, accessibility, and visual appeal. The following improvements have been made:

1. Enhanced Letter component with sophisticated animation variants:
   - Implemented optimized timing and easing functions for each animation state (idle, deleting, inserting, transitioning)
   - Added subtle bounce effects for insertion and movement animations to improve visual feedback
   - Integrated prefersReducedMotion media query support to respect user accessibility preferences
   - Applied performance optimizations including will-change CSS property and GPU acceleration for smoother animations

2. Refined CSS module with comprehensive styling:
   - Created distinct visual indicators for each animation state to improve user experience
   - Enhanced accessibility with proper focus states and appropriate contrast ratios
   - Implemented responsive design principles to ensure consistent appearance across device sizes
   - Added print styles to ensure appropriate rendering when printed
   - Optimized rendering performance with CSS containment and other best practices

3. Developed extensive Storybook documentation:
   - Created stories for each animation state (idle, deleting, inserting, transitioning)
   - Added interactive controls to demonstrate customization options
   - Included stories specifically showcasing accessibility features including reduced motion variants
   - Demonstrated keyboard navigation support and focus management
   - Provided documentation on component API and usage patterns

4. Implemented comprehensive test coverage:
   - Unit tests for all animation variants and state transitions
   - Accessibility tests verifying ARIA attributes and reduced motion compliance
   - Integration tests ensuring proper interaction with the animation state machine
   - Visual regression tests to maintain design consistency
   - Performance tests to prevent animation jank

The Letter component implementation is now complete and ready for integration with the WordTransform component. The rendering system successfully maps the transformation plan to Letter components with appropriate animation attributes, and the staggered animation system provides a smooth, visually appealing transition between states while maintaining accessibility compliance.
</info added on 2025-05-07T22:59:43.789Z>

## 5. Handle prop changes and optimize performance [pending]
### Dependencies: 5.13, 5.15, 5.19, 5.27, 5.31
### Description: Implement proper handling of prop changes during animation and optimize the component for performance.
### Details:
Decide and implement behavior for when props change mid-animation (restart, complete current animation first, etc.). Add a reset function to cleanly restart animations when words change. Implement memoization using useMemo and useCallback to prevent unnecessary re-renders. Add optional callback props for animation events (onAnimationStart, onPhaseChange, onAnimationComplete). Ensure smooth transitions between all animation phases with no visual glitches. Add final polish including accessibility attributes and responsive behavior.
<info added on 2025-05-08T02:22:58.503Z>
Decide and implement behavior for when props change mid-animation (restart, complete current animation first, etc.). Add a reset function to cleanly restart animations when words change. Implement memoization using useMemo and useCallback to prevent unnecessary re-renders. Add optional callback props for animation events (onAnimationStart, onPhaseChange, onAnimationComplete). Ensure smooth transitions between all animation phases with no visual glitches. Add final polish including accessibility attributes and responsive behavior.

Before implementing these performance optimizations, ensure that all code quality subtasks (5.27-5.31) are completed. These code improvements will establish a solid foundation for the performance work and ensure that the component follows best practices. Once the code quality improvements are in place, proceed with the prop change handling and performance optimizations as outlined above.
</info added on 2025-05-08T02:22:58.503Z>

## 6. Integrate CSS variables for animation timing [pending]
### Dependencies: 5.27, 5.28, 5.29, 5.30, 5.31
### Description: Set up and integrate CSS variables for animation timing from the stylesheet to ensure consistent animation speeds across the component.
### Details:
Create a set of CSS variables in the component's stylesheet for different animation durations and delays (e.g., --deletion-duration, --movement-duration, --insertion-duration). Implement a mechanism to modify these CSS variables based on the speedMultiplier prop. Use React's useRef to access the component's DOM element and update CSS variables programmatically. Ensure all animations reference these variables instead of hardcoded timing values. Add a helper function to calculate and update all timing variables when the speed multiplier changes.

## 7. Add data-phase attributes and testing hooks [done]
### Dependencies: 5.27
### Description: Implement data-phase attributes and testing hooks to facilitate E2E testing and debugging of the animation sequence.
### Details:
Add data-phase attributes to the component's container element that reflect the current animation phase (e.g., data-phase="deleting", data-phase="moving"). Add data-testid attributes to key elements for easier selection in tests. Create a debug mode prop that, when enabled, adds additional data attributes showing the internal state of each letter (e.g., data-letter-state="deleted", data-letter-state="moving"). Implement a testing API through ref forwarding that exposes internal state and methods for testing purposes. Document all testing hooks and attributes for the QA team.
<info added on 2025-05-10T03:01:50.166Z>
Add data-phase attributes to the component's container element that reflect the current animation phase (e.g., data-phase=\"deleting\", data-phase=\"moving\"). Add data-testid attributes to key elements for easier selection in tests. Create a debug mode prop that, when enabled, adds additional data attributes showing the internal state of each letter (e.g., data-letter-state=\"deleted\", data-letter-state=\"moving\"). Implement a testing API through ref forwarding that exposes internal state and methods for testing purposes. Document all testing hooks and attributes for the QA team.

Implementation details:
1. Added data-phase attributes to the WordTransform container element that reflect the current animation phase (e.g., data-phase="deleting")
2. Added numerous data-testid attributes to various elements for easier test selection 
3. Implemented a debug mode prop that, when enabled, adds additional data attributes to each letter showing:
   - data-letter-index: Index of letter in source/target word
   - data-is-deleted/data-is-moved/data-is-inserted: Boolean state flags
   - data-animation-active: Whether animation is currently active
   - data-extended-state: Detailed state for debugging
   - data-move-to-index: Target index for moved letters
4. Added several container-level data attributes:
   - data-debug-mode
   - data-animation-active
   - data-edit-plan-loaded
   - data-animations-progress
5. Implemented a testing API through ref forwarding that provides direct access to:
   - Current animation phase
   - Edit plan details
   - Letter arrays
   - Animation state flags
   - Direct method access to startAnimation()
6. Added comprehensive tests to verify all these features work

These changes significantly improve the testability of the component by exposing internal state and providing hooks for E2E testing tools to interact with and verify the animation process.
</info added on 2025-05-10T03:01:50.166Z>

## 8. Define and unit-test WordTransform finite state machine [pending]
### Dependencies: 5.27
### Description: Create a finite state machine for the WordTransform component that manages the animation sequence states and transitions.
### Details:
Create src/components/wordTransform.machine.ts with XState defining five states: idle, deleting, moving, inserting, and complete. Include context to track deletion/move/insertion counts. Define events (START, DONE_PHASE, RESET) that trigger transitions between states. Implement logic to skip phases with zero-length operations. Ensure the machine handles the complete animation lifecycle and can be reset.

## 9. Implement WordTransform component with FSM integration [pending]
### Dependencies: 5.8
### Description: Develop the WordTransform component that uses the state machine to orchestrate the animation sequence of Letter components.
### Details:
Create the WordTransform component that takes misspelled and correct words as props. Replace any existing useReducer/useEffect logic with useMachine(wordTransformMachine). Use the algorithm utilities from Task 2 to compute the edit plan. Render Letter components based on the current animation phase. Implement event handlers to send('START') on animation start, send('DONE_PHASE') when Letter animations complete, and send('RESET') to restart. Map the machine's current state to visual feedback and control props. Support a speed multiplier prop that affects animation duration.

## 10. Update tests and add Storybook examples [pending]
### Dependencies: 5.9
### Description: Refactor existing tests to work with the state machine implementation and create Storybook examples showcasing the component.
### Details:
Update existing Jest/React Testing Library tests to interact with the component via state machine events. Add data-phase and data-testid attributes to key elements for test selection. Create E2E tests that verify the full animation sequence works correctly. Develop Storybook examples that demonstrate different animation scenarios: words with deletions only, insertions only, movements only, and combinations. Include examples with different speed multiplier values.

## 11. Wire true-mover animation state through to Letter component and Framer Motion [done]
### Dependencies: 5.4, 5.27
### Description: Ensure the 'true-mover' animation state is passed through to the Letter component and Framer Motion. Do not collapse it to 'movement'. Add a Framer Motion variant and/or prop for true-mover in Letter. Update CSS/animation for true-mover to provide distinct visual and motion feedback.
### Details:
- Update mapToLetterAnimationState and/or Letter props to allow 'true-mover' to be passed through.
- Add a Framer Motion variant and/or prop for 'true-mover' in Letter.
- Update Letter.module.css and animation logic to provide distinct styling and motion for true-movers.
- Ensure the WordTransform component applies the correct class/data-attribute for true-movers.
- Test visually in Storybook and with unit tests.
<info added on 2025-05-10T03:07:05.578Z>
- Update mapToLetterAnimationState and/or Letter props to allow 'true-mover' to be passed through.
- Add a Framer Motion variant and/or prop for 'true-mover' in Letter.
- Update Letter.module.css and animation logic to provide distinct styling and motion for true-movers.
- Ensure the WordTransform component applies the correct class/data-attribute for true-movers.
- Test visually in Storybook and with unit tests.

Implementation completed:
1. Updated Letter.tsx to add 'true-mover' to the LetterAnimationState type
2. Created a new createTrueMoverVariant animation function with enhanced animations including scale and rotation effects
3. Added the true-mover variant to the createLetterVariants function
4. Updated utility functions (getAriaLabel, getOutlineColor) to handle the true-mover state
5. Enhanced Letter.module.css with true-mover specific styling:
   - Orange color (#ffa500) to visually distinguish from regular movers (yellow)
   - Bold font weight for emphasis
   - Enhanced text shadow/glow effects
   - Pulsing animation using @keyframes
   - More pronounced background highlight and hover state
6. Modified WordTransform.tsx:
   - Simplified the ExtendedLetterAnimationState type
   - Removed mapToLetterAnimationState transformation (Letter now supports true-mover directly)
   - Passing true-mover state directly to Letter components
7. Added comprehensive tests:
   - Verified true-mover state propagation to Letter components
   - Confirmed distinct styling between true-movers and regular movers
   - Performed visual testing to validate the orange highlighting and animations
</info added on 2025-05-10T03:07:05.578Z>

## 12. Expand Jest/RTL test suite for WordTransform: phase transitions, CSS vars, and true-mover rendering [pending]
### Dependencies: 5.11
### Description: Add integration/unit tests for WordTransform using fake timers and deterministic edit plans. Assert phase transitions (IDLE→DELETING→MOVING→INSERTING→COMPLETE), CSS variable changes for speedMultiplier, and true-mover rendering (class, data-attribute, or animation variant).
### Details:
- Use jest.useFakeTimers() and jest.runAllTimers() to control animation timing in tests.
- Mock computeEditPlan to return a known plan (e.g., for 'ab'→'ba', highlight index 0 or 1).
- Assert:
  - CSS variable changes for speedMultiplier
  - Phase transitions (IDLE → DELETING → MOVING → INSERTING → COMPLETE)
  - That a true-mover letter gets the correct class/data-attribute and/or animation variant
- Add tests to src/components/__tests__/WordTransform.test.tsx.

## 13. Fix COMPLETE-phase loop in phase transition effect [done]
### Dependencies: 5.3
### Description: Fix the issue where PhaseConfig for AnimationPhase.COMPLETE never skips, causing unnecessary renders due to dispatching START_PHASE even in COMPLETE phase.
### Details:
- Modify the phase transition effect to add a check for the COMPLETE phase.
- Only dispatch START_PHASE when not already in COMPLETE phase.
- Add a test to verify that re-renders don't occur unnecessarily after reaching COMPLETE phase.
- Update the PhaseConfig definition to properly handle the COMPLETE phase.
- Ensure the reducer correctly handles the case when START_PHASE is dispatched in COMPLETE phase.
- Update the phase transition documentation to reflect this fix.
<info added on 2025-05-08T02:18:04.076Z>
- Modify the phase transition effect to add a check for the COMPLETE phase.
- Only dispatch START_PHASE when not already in COMPLETE phase.
- Add a test to verify that re-renders don't occur unnecessarily after reaching COMPLETE phase.
- Update the PhaseConfig definition to properly handle the COMPLETE phase.
- Ensure the reducer correctly handles the case when START_PHASE is dispatched in COMPLETE phase.
- Update the phase transition documentation to reflect this fix.

This is a high-priority performance fix that addresses unnecessary re-renders in the WordTransform component. The current implementation causes the component to continuously loop through phase transitions even after reaching the COMPLETE phase, which creates performance overhead especially in components with many word transformations. This issue becomes particularly noticeable in complex UIs where multiple WordTransform components are present. The fix will significantly improve rendering efficiency by preventing these redundant cycles.
</info added on 2025-05-08T02:18:04.076Z>

## 14. Fix props-change "cancel" logic to respect cancelOnPropsChange flag [done]
### Dependencies: 5.3
### Description: Correct the issue where INITIALIZE is always dispatched on prop change regardless of cancelOnPropsChange flag, effectively ignoring the flag.
### Details:
- Modify the prop change effect to check the cancelOnPropsChange flag before dispatching INITIALIZE.
- Only dispatch INITIALIZE when cancelOnPropsChange is true during in-flight animations.
- Allow animations to continue when cancelOnPropsChange is false.
- Add test cases that verify animations continue when cancelOnPropsChange is false and props change.
- Add test cases that verify animations reset when cancelOnPropsChange is true and props change.
- Update documentation to clearly explain the behavior of the cancelOnPropsChange flag.

## 15. Fix stale edit plan on empty inputs [done]
### Dependencies: 5.2, 5.3
### Description: Correct the issue where empty misspelling or correct inputs result in null from useMemo but don't clear state.editPlan, leaving stale letters on screen.
### Details:
- Add explicit CLEAR action to clear the edit plan when inputs become empty.
- Modify the useMemo for edit plan to handle empty inputs correctly.
- Ensure the reducer properly handles the CLEAR action to reset the edit plan.
- Add test cases for empty input transitions (from valid words to empty and vice versa).
- Update the component to visually reflect empty state without showing stale letters.
- Add defensive checks to prevent rendering letters when inputs are empty.
<info added on 2025-05-10T02:46:48.646Z>
- Add explicit CLEAR action to clear the edit plan when inputs become empty.
- Modify the useMemo for edit plan to handle empty inputs correctly.
- Ensure the reducer properly handles the CLEAR action to reset the edit plan.
- Add test cases for empty input transitions (from valid words to empty and vice versa).
- Update the component to visually reflect empty state without showing stale letters.
- Add defensive checks to prevent rendering letters when inputs are empty.

Implementation details:
1. Added a new 'CLEAR' action to the AnimationAction type to handle empty input cases.
2. Updated the animationReducer to handle the 'CLEAR' action, which resets the edit plan and related state.
3. Modified the input handling effect to dispatch 'CLEAR' when either misspelling or correct props are empty.
4. Added defensive checks in the renderLetters function to prevent rendering when inputs are empty.
5. Created comprehensive test cases to verify empty input transitions and edit plan clearing behavior.
6. This fix ensures that the component properly clears any stale letters when inputs become empty, providing a consistent user experience and avoiding the display of outdated or incorrect animations.
</info added on 2025-05-10T02:46:48.646Z>

## 16. Fix CSS variable lookup for per-component overrides [pending]
### Dependencies: 5.6
### Description: Fix the issue where CSS variable lookups read from document.documentElement instead of the component's own .wordTransform element, missing per-component overrides.
### Details:
- Update CSS variable lookup to use getComputedStyle on the component's own element.
- Use useRef to track the component's DOM element.
- Apply the CSS variables directly to the .wordTransform element instead of relying on global variables.
- Ensure speedMultiplier prop correctly modifies component-level CSS variables.
- Add support for CSS variable customization via className props.
- Update test cases to verify CSS variable overrides are correctly applied.
- Document the CSS variable customization approach in comments.

## 17. Add missing exit animations for deleted letters [done]
### Dependencies: 5.4
### Description: Fix the issue where deleted letters during the moving phase are filtered out without explicit exit variants, causing them to vanish abruptly.
### Details:
- Add explicit exit variant to the Letter component for deleted letters.
- Ensure AnimatePresence is properly configured to handle exit animations.
- Update the filtering logic in the moving phase to maintain letters that are being deleted.
- Add a specific 'exiting' animation state for letters being removed.
- Set appropriate exit delay and duration for smooth animation.
- Test that letters properly animate out instead of abruptly disappearing.
- Update CSS styling to ensure exit animations are visually pleasing.
<info added on 2025-05-08T02:18:42.630Z>
- Add explicit exit variant to the Letter component for deleted letters.
- Ensure AnimatePresence is properly configured to handle exit animations.
- Update the filtering logic in the moving phase to maintain letters that are being deleted.
- Add a specific 'exiting' animation state for letters being removed.
- Set appropriate exit delay and duration for smooth animation.
- Test that letters properly animate out instead of abruptly disappearing.
- Update CSS styling to ensure exit animations are visually pleasing.

This is a medium-high priority issue as it directly impacts the user experience. The abrupt disappearance of letters creates a jarring visual effect that breaks the smooth flow of the WordTransform component. Users may perceive this as a bug or glitch in the interface, reducing confidence in the application. Implementing proper exit animations will significantly improve the perceived quality and polish of the component.
</info added on 2025-05-08T02:18:42.630Z>
<info added on 2025-05-10T02:40:03.445Z>
- Add explicit exit variant to the Letter component for deleted letters.\n- Ensure AnimatePresence is properly configured to handle exit animations.\n- Update the filtering logic in the moving phase to maintain letters that are being deleted.\n- Add a specific 'exiting' animation state for letters being removed.\n- Set appropriate exit delay and duration for smooth animation.\n- Test that letters properly animate out instead of abruptly disappearing.\n- Update CSS styling to ensure exit animations are visually pleasing.\n<info added on 2025-05-08T02:18:42.630Z>\n- Add explicit exit variant to the Letter component for deleted letters.\n- Ensure AnimatePresence is properly configured to handle exit animations.\n- Update the filtering logic in the moving phase to maintain letters that are being deleted.\n- Add a specific 'exiting' animation state for letters being removed.\n- Set appropriate exit delay and duration for smooth animation.\n- Test that letters properly animate out instead of abruptly disappearing.\n- Update CSS styling to ensure exit animations are visually pleasing.\n\nThis is a medium-high priority issue as it directly impacts the user experience. The abrupt disappearance of letters creates a jarring visual effect that breaks the smooth flow of the WordTransform component. Users may perceive this as a bug or glitch in the interface, reducing confidence in the application. Implementing proper exit animations will significantly improve the perceived quality and polish of the component.\n</info added on 2025-05-08T02:18:42.630Z>\n\nImplementation completed successfully with the following changes:\n\n1. Added a new 'exiting' animation state to the Letter component specifically designed to handle letters being removed from the DOM\n2. Updated the Letter component with proper exit animations including fade-out and scale effects\n3. Modified the WordTransform component logic to mark deleted letters with the 'exiting' state during the moving phase instead of immediately filtering them out\n4. Added CSS styling for the exiting animation state with appropriate opacity and transform transitions\n5. Configured the AnimatePresence component to use 'mode=\"sync\"' for better coordination of exit animations with other ongoing animations\n6. Updated the phase transition logic to include deleted letters in the moving phase animation count to ensure all animations complete before proceeding\n7. Created and executed a test case to verify that deleted letters properly animate out rather than disappearing abruptly\n\nThe implementation provides a more polished and professional user experience by ensuring smooth visual transitions when letters are removed from the word transformation process.
</info added on 2025-05-10T02:40:03.445Z>

## 18. Add ARIA live region for phase changes [pending]
### Dependencies: 5.3, 5.7
### Description: Implement an ARIA live region to announce high-level phase transitions (e.g. "Deleting 3 letters…"), improving accessibility beyond individual letter roles. [Updated: 5/7/2025]
### Details:
- Add an ARIA live region to the WordTransform component.
- Create informative messages for each animation phase (e.g., "Deleting 3 letters", "Moving 2 letters", "Adding 1 letter").
- Update the phase change logic to announce appropriate messages.
- Ensure proper aria-live attribute settings (polite for non-critical updates).
- Respect user preferences for verbosity and reduced motion.
- Add internationalization support for the announcement messages.
- Test with screen readers to verify proper announcements.
<info added on 2025-05-08T02:18:27.262Z>
- Add an ARIA live region to the WordTransform component.
- Create informative messages for each animation phase (e.g., \"Deleting 3 letters\", \"Moving 2 letters\", \"Adding 1 letter\").
- Update the phase change logic to announce appropriate messages.
- Ensure proper aria-live attribute settings (polite for non-critical updates).
- Respect user preferences for verbosity and reduced motion.
- Add internationalization support for the announcement messages.
- Test with screen readers to verify proper announcements.

This accessibility feature should be prioritized as medium-high importance since it provides critical context for users with visual impairments. Without these announcements, users relying on screen readers would miss the visual transformations happening in the component, creating a significant accessibility gap. This implementation directly supports WCAG 2.1 Success Criterion 4.1.3 (Status Messages) which requires that status messages can be programmatically determined so they can be presented to users of assistive technologies without receiving focus.
</info added on 2025-05-08T02:18:27.262Z>

## 19. Implement restart/replay functionality [pending]
### Dependencies: 5.3
### Description: Add the ability to restart or replay the same transformation after reaching the COMPLETE phase, as required by the spec.
### Details:
- Add a RESTART action to the WordTransform reducer.
- Implement a restart button that appears in the COMPLETE phase.
- Update the machine to allow transitions from COMPLETE back to IDLE.
- Ensure the edit plan is preserved for replay without recalculation.
- Add a callback prop for onRestart to notify parent components.
- Style the restart button to match the application design.
- Add keyboard support for the restart functionality (e.g., spacebar or Enter key).
- Test that animations work correctly when replayed multiple times.
<info added on 2025-05-08T02:18:14.468Z>
- Add a RESTART action to the WordTransform reducer.
- Implement a restart button that appears in the COMPLETE phase.
- Update the machine to allow transitions from COMPLETE back to IDLE.
- Ensure the edit plan is preserved for replay without recalculation.
- Add a callback prop for onRestart to notify parent components.
- Style the restart button to match the application design.
- Add keyboard support for the restart functionality (e.g., spacebar or Enter key).
- Test that animations work correctly when replayed multiple times.

This is a core feature required by the specification, not an optional enhancement or bug fix. The restart functionality is essential for the WordTransform component's complete operation and user experience. Implementation should be prioritized accordingly.
</info added on 2025-05-08T02:18:14.468Z>

## 20. Make test hooks consistent across source and target letters [pending]
### Dependencies: 5.4, 5.7
### Description: Fix inconsistency where data-extended-state is added on source letters but insertion/movement states and data-indices aren't exposed on target letters in the same way.
### Details:
- Create a helper function to generate consistent data attributes for both source and target letters.
- Ensure data-extended-state, data-index, and other attributes are applied consistently.
- Add the missing data-indices on target letters to match source letters.
- Ensure insertion/movement states are properly exposed on target letters.
- Document the test hook attributes in component comments.
- Add test cases to verify consistency of data attributes.
- Create a comprehensive testing guide for QA to understand available hooks.

## 21. Extract sub-renderers for better modularity [pending]
### Dependencies: 5.4
### Description: Extract the "render source letters" and "render target letters" blocks into small memoized components to isolate rendering logic.
### Details:
- Create SourceLetters and TargetLetters components extracted from WordTransform.
- Memoize these components using React.memo to prevent unnecessary re-renders.
- Define clear prop interfaces for these components.
- Pass only the necessary props from WordTransform to each component.
- Handle edge cases like empty strings or null edit plans within these components.
- Update tests to reflect the new component structure.
- Document the component structure and responsibilities in comments.

## 22. Lift phaseConfig out of effect for better performance [pending]
### Dependencies: 5.3
### Description: Move the phaseConfig map outside of the effect to avoid re-creating it on every phase change, improving performance.
### Details:
- Move the phaseConfig map outside of the useEffect hook.
- Define it once at the component level or in a useMemo with minimal dependencies.
- Ensure the configuration is properly typed with TypeScript.
- Update all references to the phaseConfig in the effect.
- Modify any dynamic aspects of the configuration to work with this new structure.
- Test performance with React DevTools profiler before and after the change.
- Document the performance optimization in comments.

## 23. Unify animation duration values [pending]
### Dependencies: 5.4, 5.6
### Description: Unify duration values by reading from CSS variables via getComputedStyle instead of hard-coding base values in createLetterVariants.
### Details:
- Update createLetterVariants to read duration values from CSS variables using getComputedStyle.
- Set up a mechanism to pass the container element to Letter components.
- Remove hardcoded duration values from Letter component variants.
- Ensure CSS variables are properly defined and accessible.
- Synchronize the duration values between CSS and JS.
- Add fallback values for when CSS variables aren't available.
- Test performance with this approach to ensure smooth animations.

## 24. Cache callbacks with useCallback for reduced re-renders [pending]
### Dependencies: 5.3
### Description: Wrap startAnimation, handleLetterAnimationComplete in useCallback to reduce re-renders in deeply nested letter lists.
### Details:
- Implement useCallback for all event handler functions in WordTransform.
- Carefully define dependency arrays to avoid stale closures.
- Apply to startAnimation, handleLetterAnimationComplete, and other handler functions.
- Test render performance with React DevTools profiler.
- Compare re-render counts before and after the optimization.
- Use React.memo on Letter component to maximize the benefit.
- Document optimization techniques in component comments.

## 25. Simplify reducer types with discriminated union [pending]
### Dependencies: 5.3
### Description: Convert AnimationAction union into a proper TypeScript discriminated union to remove duplicated type fields and improve compile-time safety.
### Details:
- Refactor AnimationAction to use a discriminated union pattern with a 'type' property.
- Remove redundant type fields from action interfaces.
- Update the reducer to use the new type pattern for cleaner switch statements.
- Add exhaustiveness checking using TypeScript's never type.
- Ensure strict type checking for all action handlers.
- Update all action creators to match the new type format.
- Improve error messages for invalid state transitions.

## 26. Centralize test hooks with a helper function [pending]
### Dependencies: 5.7, 5.20
### Description: Create a helper function that generates consistent data-testid, data-state, and data-index attributes for both source and target letters.
### Details:
- Create a centralized helper function like getLetterTestProps(letter, index, phase, state).
- Use this helper consistently for both source and target letters.
- Return all necessary test attributes in a standard format.
- Apply these attributes in a consistent manner for both letter types.
- Document the available test hooks for QA team reference.
- Add test cases to verify consistent attribute application.
- Create a type definition for the helper function return value.

## 27. Refactor high-complexity arrow functions in Letter.tsx [done]
### Dependencies: 5.4
### Description: Extract complex arrow functions into named helpers or split into smaller functions to reduce ESLint complexity to ≤ 10.
### Details:
- Identify arrow functions in Letter.tsx with high cyclomatic complexity.
- Break down the createLetterVariants function into smaller, more focused helper functions.
- Extract logical sections of complex functions into named helper functions.
- Ensure each function follows the single responsibility principle.
- Maintain proper TypeScript typings for all extracted functions.
- Add appropriate JSDoc comments to document each function's purpose.
- Verify that the refactored code maintains the same functionality.
- Run ESLint to confirm complexity metrics are now below the threshold.
<info added on 2025-05-08T02:23:32.324Z>
- Identify arrow functions in Letter.tsx with high cyclomatic complexity.
- Break down the createLetterVariants function into smaller, more focused helper functions.
- Extract logical sections of complex functions into named helper functions.
- Ensure each function follows the single responsibility principle.
- Maintain proper TypeScript typings for all extracted functions.
- Add appropriate JSDoc comments to document each function's purpose.
- Verify that the refactored code maintains the same functionality.
- Run ESLint to confirm complexity metrics are now below the threshold.

This refactoring task is a prerequisite for upcoming performance optimizations. Complex arrow functions make the code harder to understand, test, and optimize. By breaking down these functions into smaller, well-named components, we'll create a more maintainable codebase that will be easier to optimize in subsequent tasks. The refactoring should focus on readability and maintainability without introducing performance regressions.
</info added on 2025-05-08T02:23:32.324Z>
<info added on 2025-05-10T02:57:47.508Z>
- Identify arrow functions in Letter.tsx with high cyclomatic complexity.
- Break down the createLetterVariants function into smaller, more focused helper functions.
- Extract logical sections of complex functions into named helper functions.
- Ensure each function follows the single responsibility principle.
- Maintain proper TypeScript typings for all extracted functions.
- Add appropriate JSDoc comments to document each function's purpose.
- Verify that the refactored code maintains the same functionality.
- Run ESLint to confirm complexity metrics are now below the threshold.
<info added on 2025-05-08T02:23:32.324Z>
- Identify arrow functions in Letter.tsx with high cyclomatic complexity.
- Break down the createLetterVariants function into smaller, more focused helper functions.
- Extract logical sections of complex functions into named helper functions.
- Ensure each function follows the single responsibility principle.
- Maintain proper TypeScript typings for all extracted functions.
- Add appropriate JSDoc comments to document each function's purpose.
- Verify that the refactored code maintains the same functionality.
- Run ESLint to confirm complexity metrics are now below the threshold.

This refactoring task is a prerequisite for upcoming performance optimizations. Complex arrow functions make the code harder to understand, test, and optimize. By breaking down these functions into smaller, well-named components, we'll create a more maintainable codebase that will be easier to optimize in subsequent tasks. The refactoring should focus on readability and maintainability without introducing performance regressions.
</info added on 2025-05-08T02:23:32.324Z>

The Letter.tsx component has been successfully refactored to reduce complexity and improve maintainability. The following changes were implemented:

1. The complex `createLetterVariants` function was broken down into smaller, focused helper functions:
   - Created separate functions for each animation state variant (normal, deletion, insertion, movement, exiting)
   - Implemented a central `getDuration` helper function to handle animation duration calculation logic

2. Extracted utility functions from the component body:
   - `createDataAttributes` - Generates consistent test and accessibility attributes
   - `createClassNames` - Constructs CSS class lists based on animation state
   - `getOutlineColor` - Determines the correct outline color based on component state
   - `createAnimationCompleteHandler` - Creates a consistent animation completion handler

3. Added comprehensive JSDoc comments for all extracted functions to improve code documentation and developer experience.

4. Added `displayName` to the component for better debugging in React DevTools.

5. Enhanced ARIA support with proper handling of the 'exiting' state.

6. Verified all tests continue to pass with the new implementation.

This refactoring has significantly improved code maintainability by adhering to the single responsibility principle. Each function now has a clear, specific purpose, and the overall cyclomatic complexity has been reduced below the ESLint threshold of 10. The changes will facilitate future maintenance and optimization of the Letter component.
</info added on 2025-05-10T02:57:47.508Z>

## 28. Tighten TypeScript typings in mocks and tests [pending]
### Dependencies: 5.4
### Description: Replace all 'any' types in mocks and tests with proper interfaces and remove or strongly type any unused function parameters.
### Details:
- Scan __mocks__ directory for any uses of 'any' type.
- Replace generic 'any' types with specific interfaces or types.
- Create new interfaces where necessary to properly type mock objects.
- Review all test files for 'any' types and replace them with proper types.
- Check for unused function parameters and either remove them or add proper types.
- Update mock implementations to use TypeScript's type guards where appropriate.
- Ensure type definitions are exported for reuse where needed.
- Verify tests still pass after type improvements.
<info added on 2025-05-08T02:23:48.464Z>
- Scan __mocks__ directory for any uses of 'any' type.
- Replace generic 'any' types with specific interfaces or types.
- Create new interfaces where necessary to properly type mock objects.
- Review all test files for 'any' types and replace them with proper types.
- Check for unused function parameters and either remove them or add proper types.
- Update mock implementations to use TypeScript's type guards where appropriate.
- Ensure type definitions are exported for reuse where needed.
- Verify tests still pass after type improvements.

This task is a high priority TypeScript improvement that must be completed before performance optimizations can begin. Proper typing will ensure type safety throughout the codebase and prevent potential runtime errors. Focus on the WordTransform component and related files first, as this appears to be part of a larger refactoring effort based on the adjacent subtasks.
</info added on 2025-05-08T02:23:48.464Z>

## 29. Prune dead code from components and utilities [pending]
### Dependencies: 5.4
### Description: Delete unused variables, imports, and stray helper functions no longer invoked throughout the codebase.
### Details:
- Use ESLint's no-unused-vars rule to identify unused variables in components.
- Remove unused imports from all component files, particularly WordTransform.tsx and Letter.tsx.
- Check for unused variables like 'definition' and 'mockAnimationComplete'.
- Identify and remove any helper functions that are no longer called.
- Clean up any commented-out code that's not needed for reference.
- Remove any duplicate utility functions.
- Check for and remove unused CSS classes in module CSS files.
- Run a full test suite to ensure removal of code doesn't break functionality.
<info added on 2025-05-08T02:24:10.306Z>
- Use ESLint's no-unused-vars rule to identify unused variables in components.
- Remove unused imports from all component files, particularly WordTransform.tsx and Letter.tsx.
- Check for unused variables like 'definition' and 'mockAnimationComplete'.
- Identify and remove any helper functions that are no longer called.
- Clean up any commented-out code that's not needed for reference.
- Remove any duplicate utility functions.
- Check for and remove unused CSS classes in module CSS files.
- Run a full test suite to ensure removal of code doesn't break functionality.
- This cleanup task must be completed before performance optimizations to prevent wasting time optimizing code that will be removed.
- Focus especially on the WordTransform component and its related utilities as this is the parent task's focus area.
- Create a report of all removed code with line counts to document the cleanup effort.
- Coordinate with the team members working on TypeScript typings (subtask 5.28) to ensure alignment in code cleanup efforts.
</info added on 2025-05-08T02:24:10.306Z>

## 30. Fix React-specific lint errors [pending]
### Dependencies: 5.4
### Description: Fix various React-specific lint errors including adding displayName to anonymous components, repairing missing hook dependencies, and escaping JSX entities in stories.
### Details:
- Add displayName property to all memo and anonymous components for better debugging.
- Review all useEffect, useMemo, and useCallback hooks to ensure dependency arrays are complete.
- Focus particularly on WordTransform.tsx to fix missing dependencies in hooks.
- Check all Storybook stories for unescaped JSX entities (like &, >, <) and escape them properly.
- Review PropTypes usage and ensure they are correctly defined.
- Use the React linting rules to identify any other React-specific issues.
- Fix any React key warnings that might appear in the console.
- Ensure all components use function declarations or arrow functions consistently.
<info added on 2025-05-08T02:24:24.064Z>
- Add displayName property to all memo and anonymous components for better debugging.
- Review all useEffect, useMemo, and useCallback hooks to ensure dependency arrays are complete.
- Focus particularly on WordTransform.tsx to fix missing dependencies in hooks.
- Check all Storybook stories for unescaped JSX entities (like &, >, <) and escape them properly.
- Review PropTypes usage and ensure they are correctly defined.
- Use the React linting rules to identify any other React-specific issues.
- Fix any React key warnings that might appear in the console.
- Ensure all components use function declarations or arrow functions consistently.
- This is a high priority task that must be completed before moving on to performance optimizations.
- Fixing these React-specific lint errors is critical for maintaining code quality and preventing potential bugs in the WordTransform component.
- Pay special attention to the React hooks exhaustive-deps rule violations as they can lead to subtle bugs and performance issues.
- After fixes are applied, verify that no new console warnings appear during component rendering.
</info added on 2025-05-08T02:24:24.064Z>

## 31. Ensure clean linter and test runs [pending]
### Dependencies: 5.27, 5.28, 5.29, 5.30
### Description: Re-run linters and tests to ensure zero errors/warnings, all tests pass, and no new code clones are introduced.
### Details:
- Run `npm run lint` and fix any remaining errors or warnings.
- Run `npm test` to ensure all tests pass after code changes.
- Run `npx jscpd src` to check for code duplication and address any issues.
- Fix any TypeScript errors that may have been introduced during refactoring.
- Run Storybook to ensure visual tests are still passing.
- Check for any accessibility warnings in the console.
- Verify that all test files have appropriate coverage.
- Document any patterns or issues found for future reference.
<info added on 2025-05-08T02:24:42.870Z>
- Run `npm run lint` and fix any remaining errors or warnings.\n- Run `npm test` to ensure all tests pass after code changes.\n- Run `npx jscpd src` to check for code duplication and address any issues.\n- Fix any TypeScript errors that may have been introduced during refactoring.\n- Run Storybook to ensure visual tests are still passing.\n- Check for any accessibility warnings in the console.\n- Verify that all test files have appropriate coverage.\n- Document any patterns or issues found for future reference.\n\nThis is a critical verification step that must be completed with high attention to detail. The WordTransform component implementation cannot be considered complete until all code quality checks pass without errors or warnings. Given that this follows several implementation and refactoring subtasks (including fixing React-specific lint errors), it's essential to ensure no regressions were introduced. Prioritize addressing any issues found immediately rather than letting them accumulate. Document all fixes made for team knowledge sharing.
</info added on 2025-05-08T02:24:42.870Z>

